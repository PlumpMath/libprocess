/* TODO(benh): Write a form of 'Client' process. */

#ifndef NET_HPP
#define NET_HPP

#include <assert.h>
#include <errno.h>
#include <fcntl.h>

#include <process.hpp>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#include <sys/ioctl.h>
#include <sys/socket.h>

#include <iostream>

typedef enum Protocol { TCP = SOCK_STREAM, UDP = SOCK_DGRAM } Protocol;


template <Protocol protocol>
class SocketProcess : public Process
{
protected:
  int s;

  void setsockopt(int level, int optname, const void *optval, socklen_t optlen)
  {
    if (::setsockopt(s, level, optname, optval, optlen) < 0)
      abort();
  }

  virtual void socket()
  {
    if ((s = ::socket(AF_INET, protocol, IPPROTO_IP)) < 0)
      abort();
    
    int flags = 1;
    if (ioctl(s, FIONBIO, &flags) &&
	((flags = fcntl(s, F_GETFL, 0)) < 0 ||
	 fcntl(s, F_SETFL, flags | O_NONBLOCK) < 0))
      abort();
  }

  virtual void socket(int _s)
  {
    s = _s;
    
    int flags = 1;
    if (ioctl(s, FIONBIO, &flags) &&
	((flags = fcntl(s, F_GETFL, 0)) < 0 ||
	 fcntl(s, F_SETFL, flags | O_NONBLOCK) < 0))
      abort();
  }

  virtual void close()
  {
    if (::close(s) < 0)
      abort();
  }

  virtual void bind(in_addr_t ip, in_port_t port)
  {
    struct sockaddr_in addr;
    addr.sin_family = PF_INET;
    addr.sin_addr.s_addr = ip;
    addr.sin_port = htons(port);

    if (::bind(s, (struct sockaddr *) &addr, sizeof(addr)) < 0)
      abort();
  }

  virtual ssize_t read(void *buf, size_t bytes)
  {
    ssize_t len;
    do {
      await(s, RDONLY);
      
      len = ::read(s, buf, bytes);

      if (len == 0)
	abort();
      else if (len < 0 && (errno != EAGAIN && errno != EINTR))
	abort();
    } while (!(len > 0));

    return len;
  }
  
  virtual void write(const void *buf, size_t bytes)
  {
    size_t offset = 0;
    do {
      await(s, WRONLY);
      
      size_t len = ::write(s, (char *) buf + offset, bytes - offset);
      
      if (len == 0)
	abort();
      else if (len < 0 && (errno != EAGAIN && errno != EINTR))
	abort();
      
      offset += len;
    } while (offset != bytes);
  }
  
public:
  SocketProcess() : s(-1) {}
  SocketProcess(int _s) : s(_s)
  {
    int flags = 1;
    if (ioctl(s, FIONBIO, &flags) &&
	((flags = fcntl(s, F_GETFL, 0)) < 0 ||
	 fcntl(s, F_SETFL, flags | O_NONBLOCK) < 0))
      abort();
  }
};


template <Protocol protocol>
class Acceptor : public SocketProcess<protocol>
{
protected:
  virtual int accept(struct sockaddr_in &addr)
  {
    int c;

    do {
      await(SocketProcess<protocol>::s, Process::RDONLY);

      size_t size = sizeof(struct sockaddr_in);

      c = ::accept(SocketProcess<protocol>::s,
		       (struct sockaddr *) &addr,
		       (socklen_t *) &size);
    
      if (c == 0)
	abort();
      else if (c < 0 && (errno != EAGAIN && errno != EINTR))
	abort();
    } while (!(c > 0));
    
    return c;
  }

public:
  Acceptor() {}
  Acceptor(int s) : SocketProcess<protocol>(s) {}
};


template <Protocol protocol>
class Server : public Acceptor<protocol>
{
protected:
  in_addr_t ip;
  in_port_t port;

  void init(in_addr_t _ip = INADDR_ANY, in_port_t _port = 0)
  {
    ip = _ip;
    port = _port;
    SocketProcess<protocol>::socket();
  }

  virtual void listen(int n)
  {
    int &s = SocketProcess<protocol>::s;
    if (::listen(s, n) < 0)
      abort();
  }

  virtual void bind()
  {
    SocketProcess<protocol>::bind(ip, port);
  }

  ssize_t read(void *buf, size_t bytes)
  {
    abort();
  }

  void write(const void *buf, size_t bytes)
  {
    abort();
  }

public:
  Server(in_addr_t _ip = INADDR_ANY, in_port_t _port = 0)
    : ip(_ip), port(_port)
  {
    SocketProcess<protocol>::socket();
  }

  ~Server()
  {
    SocketProcess<protocol>::close();
  }
};


#endif /* NET_HH */
